<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Tetris Blokkspill</title>
<link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAETElEQVR4AbSXS2xbRRSGv7m245uEPCGBtI0CjVRVqBUFRQUKSlECSBQJIVDZs+EhARskYNUQNjx33fBYsGDHBgmQiigtFUWtAAlStaiqIKJJlSblmUfjtz2cM7d2bcd27DyuZubOmTlz/n/OnDO+9ljjc+4gTYkxDsfHyMYP8aV9lY61mFoTAfspTbfv57OmXl4IteJheDTpc2L+NboaJeE1usB+QIR/+cJEOGDCEJF9h9vBwp5olO8WxuhuxKbXiLIdIyxIXxNtf5hoZ2Fp+AZQEjKwq8nys32FNunXVby6tETJHiREHydp7n6AgRHo3iGj14sj0SGyYSDhc96+SFSkVUvdBBjlAn7nPfQPB0bnJ4N3URtuhYg6xrA13sWloqmqXa/qTNGEfZ/fae/bTv/+YPTSSYj/E/TLWq8ZIhKKxtAj2TFdNr1C9FaMlA048I6t27l5r0GsMn0CEpXBdamqeD5EukUy9EuaXpFe1eJVm9Ezd+C6896hAHzqOCTnqy0pjDsSEgHqCRnsrUWiIgGXaqNM0NY3WNj51DFILVLv40ioJ+Q4ZE1v7BB/VgrMFQQk1XxJtVN0De6i726c2x34Eo0+xSSk35PoYrI8RUsIyM5b2MIxOgeH6Nkd4E1/KztvHDxYjOPvYqILkOyQFD1bfFkVCNh3aZWdHyHk76NXwG0OLh6VM19gvY/snpBkRzhI0YGo5UfxtEo4Am7nbXxOKDxMOApXfhHwbyC9vF7skvXhFgh3gDUMJuD04svc5KmGzfKJuGeEvr2w5V5YnIJMTKc2vOplpbemGN7Z1MpxR8CEeEIG4O9f4a+zrruZjR6H2hdP7HYEsHysAyTlvK/OuO5mNpl4YF1i42hAIMXzWCTigonNbLMSVtmrgmD5YSnGk46AeYmk/HY9JiQk52Ryk0pWwiotTjaWM77HSM87LDkCimeeJkGKR4TE9ypvZLXytZIVt6f1FrdMRmPcZ15H6ECBgAI6T8wySo6fVN6IquA5ybn0f87a5YUYd5j3kINwcikBHTLj4oc59mE5rfJ6qgPXnQu49Gf8WW69pQhcbZd4QAe0CokMs9wvJCZEFgdK22ARQHJxucsCt8+0vME28yHpcjMVCaiSkMiZ57hT+mekNkTCgavbr4E3C7jYqFiqEshrm2eFhKXmR0VeN//On7kQmakFrvqrElAlutkmx/GH66/SuFSTMxe1y81z3CbvmqUuAuYpshITOyU7zteyppdMWt0OFxeW2VHpzMvX10VAF0lMpPC5SzyhgalDJTWzLAEnl4zM/+Yn2FMe7SXKRULdBHSN0ctqFvm55JTK+ZqRqzWj4HAuZhgyb7OQn1vt3RABNWbGScj7IZvmK/kZR6/WjHwqGphIJhm+cRyRRKPO0jABtSuZETMXeDw5x0dy7jnjcSSV4sHOtwjCj/qfNRFQ8+YwSUmxZ5rHCfljHGh/k4p/FlS3Vv0fAAD//7Yw3ogAAAAGSURBVAMAXftMUAEzcd0AAAAASUVORK5CYII=">

<style>
body::before {
content: '';
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100vh;
z-index: -1;
background-image: url("data:image/svg+xml,<svg width='40' height='40' xmlns='http://www.w3.org/2000/svg'><rect width='40' height='40' fill='%23030328'/><path d='M40 0v40H0' fill='none' stroke='%2300d1ff' stroke-width='0.5'/></svg>");
background-size: 40px;
background-repeat: repeat;
background-position: top;
opacity: 0.90;
filter: blur(0px);
}
:root {
--primary-color: #00ffff;
--secondary-color: #ff00ff;
--score-color: #00ff00;
--reward-color: #ffff00;
--dark-bg: #000000;
--black-bg: #000000;
--text-color: #e0e0e0;
--game-over-color: #ff0000;
}
body {
display: flex;
justify-content: center;
align-items: center;
min-height: 100vh;
background-color: #121212;
color: var(--text-color);
overflow: hidden;
font-family: 'Courier New', Courier, monospace;
margin: 0;
padding: 0;
box-sizing: border-box;
}
.game-container {
display: flex;
gap: 3vh;
background-color: var(--dark-bg);
padding: 2vh;
border-radius: 2vh;
box-shadow: 0 0 5vh rgba(0, 255, 255, 0.6),
0 0 2.5vh rgba(0, 255, 255, 0.4) inset;
border: 0.4vh solid var(--primary-color);
position: relative;
}
canvas#gameCanvas {
background-color: var(--black-bg);
border: 0.3vh solid var(--primary-color);
box-shadow: 0 0 2.5vh rgba(0, 255, 255, 0.5);
display: block;
}
.info-panel,
.highscore-panel {
display: flex;
flex-direction: column;
justify-content: flex-start;
align-items: center;
width: 30vh;
padding: 2vh;
background-color: var(--dark-bg);
border-radius: 1.5vh;
border: 0.3vh solid var(--secondary-color);
box-shadow: 0 0 3vh rgba(255, 0, 255, 0.6),
0 0 1.5vh rgba(255, 0, 255, 0.4) inset;
}
.highscore-panel {
display: flex;
flex-direction: column;
border-color: var(--score-color);
box-shadow: 0 0 3vh rgba(0, 255, 0, 0.6),
0 0 1.5vh rgba(0, 255, 0, 0.4) inset;
}
.highscore-panel h2 {
font-size: 3.6vh;
color: var(--score-color);
text-shadow: 0 0 1vh var(--score-color);
margin: 0 0 1.5vh 0;
}
.highscore-panel ol {
text-align: left;
width: 100%;
padding-left: 3vh;
margin: 0;
font-size: 3.1vh;
color: var(--text-color);
list-style-type: decimal;
}
.highscore-panel li {
margin-bottom: 0.8vh;
text-shadow: 0 0 0.5vh var(--primary-color);
}
.info-section {
width: 100%;
text-align: center;
margin-bottom: 1.5vh;
}
.info-section h2 {
font-size: 3.4vh;
color: var(--score-color);
text-shadow: 0 0 1vh var(--score-color);
margin: 0 0 0.5vh 0;
}
.info-section p {
font-size: 4.5vh;
color: var(--primary-color);
text-shadow: 0 0 0.8vh var(--primary-color);
margin: 0;
}
#nextPieceCanvas {
background-color: #050505;
border: 0.2vh solid var(--score-color);
box-shadow: 0 0 1.5vh rgba(0, 255, 0, 0.5);
margin-top: 1vh;
margin-bottom: 2vh;
width: 100%;
height: 12vh;
}
.reward-window {
width: 100%;
height: 25vh;
background-color: var(--black-bg);
border: 0.4vh solid var(--reward-color);
box-shadow: 0 0 3vh rgba(255, 255, 0, 0.6),
0 0 1.5vh rgba(255, 255, 0, 0.4) inset;
display: flex;
justify-content: center;
align-items: center;
overflow: hidden;
border-radius: 1vh;
margin-top: auto;
}
#rewardEmoji {
font-size: 16vh;
line-height: 1;
}
@keyframes pop-in {
from {
transform: scale(0.1) rotate(-45deg);
opacity: 0;
}
to {
transform: scale(1) rotate(0deg);
opacity: 1;
}
}
.pop-in-animation {
animation: pop-in 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}
.game-over-screen {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.85);
display: none;
flex-direction: column;
justify-content: center;
align-items: center;
font-size: 7vh;
color: var(--game-over-color);
text-shadow: 0 0 2vh var(--game-over-color);
z-index: 100;
border-radius: 1.8vh;
text-align: center;
}
.game-over-screen button {
background-color: var(--score-color);
color: var(--dark-bg);
border: 0.3vh solid #00cc00;
padding: 2vh 4vh;
font-family: 'Courier New', Courier, monospace;
font-size: 2.5vh;
cursor: pointer;
border-radius: 1vh;
box-shadow: 0 0 1.5vh rgba(0, 255, 0, 0.7);
transition: transform 0.2s, box-shadow 0.2s;
margin-top: 3vh;
}
.game-over-screen button:hover {
transform: scale(1.05);
box-shadow: 0 0 2.5vh rgba(0, 255, 0, 1);
}
#resetHighscoreButton {
background-color: var(--game-over-color);
color: var(--text-color);
border: 0.3vh solid #cc0000;
padding: 1.5vh 3vh;
font-family: 'Courier New', Courier, monospace;
font-size: 2.2vh;
cursor: pointer;
border-radius: 1vh;
box-shadow: 0 0 1.5vh rgba(255, 0, 0, 0.7);
transition: transform 0.2s, box-shadow 0.2s;
margin-top: auto;
}
#resetHighscoreButton:hover {
transform: scale(1.05);
box-shadow: 0 0 2.5vh rgba(255, 0, 0, 1);
}
#controls {
width: 100%;
margin-top: 2vh;
font-size: 2vh;
color: var(--secondary-color);
opacity: 0.8;
}
#controls div {
display: flex;
align-items: center;
margin-bottom: 0.8vh;
}
#controls span.key {
display: inline-block;
background-color: #222;
border: 1px solid var(--secondary-color);
border-radius: 0.5vh;
padding: 0.3vh 1vh;
margin-right: 1.5vh;
font-weight: bold;
color: var(--text-color);
min-width: 4vh;
text-align: center;
}
.game-container.paused::before {
content: attr(data-pause-text);
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
display: flex;
justify-content: center;
align-items: center;
font-size: 10vh;
color: var(--reward-color);
background-color: rgba(15, 15, 28, 0.85);
text-shadow: 0 0 2vh var(--reward-color);
z-index: 200;
border-radius: 2vh;
pointer-events: none;
}
#gameStatusScreen a {
margin-top: 4vh;
font-size: 2vh;
color: var(--text-color);
text-decoration: none;
opacity: 0.6;
transition: opacity 0.2s;
}
#gameStatusScreen a:hover {
opacity: 1;
}
h1 {
text-align: center;
font-size: 1.34rem;
}
</style>
</head>
<body>
<div class="game-container">
<div class="info-panel">
<div class="info-section">
<h2 id="score-label"></h2>
<p id="score">0</p>
</div>
<div class="info-section">
<h2 id="level-label"></h2>
<p id="level">1</p>
</div>
<div class="info-section">
<h2 id="next-label"></h2>
<canvas id="nextPieceCanvas"></canvas>
<div id="controls">
<div id="controls-move"><span class="key">‚Üê ‚Üí</span><span class="action-text"></span></div>
<div id="controls-rotate"><span class="key">‚Üë</span><span class="action-text"></span></div>
<div id="controls-speed"><span class="key">‚Üì</span><span class="action-text"></span></div>
<div id="controls-drop"><span class="key">Space</span><span class="action-text"></span></div>
<div id="controls-pause"><span class="key">P</span><span class="action-text"></span></div>
</div>
</div>
<div class="reward-window">
<div id="rewardEmoji" aria-label="Bel√∏nnings-emoji"></div>
</div>
</div>
<canvas id="gameCanvas"></canvas>
<div class="highscore-panel">
<h1 id="main-title"></h1>
<h2 id="highscore-title"></h2>
<ol id="highscore-list"></ol>
<button id="resetHighscoreButton"></button>
</div>
<div class="game-over-screen" id="gameStatusScreen">
<div id="statusMessage"></div>
<button id="statusButton"></button>
</div>
</div>
<script>
const lang = {
title: "Tetris",
score: "Poeng",
level: "Niv√•",
next: "Neste",
controlsMove: "Flytt",
controlsRotate: "Roter",
controlsSpeed: "√òk fart",
controlsDrop: "Slipp",
controlsPause: "Pause",
highscoreTitle: "Topp 10",
resetScores: "Nullstill rekorder",
welcome: "Velkommen til Tetris",
startGame: "Start spillet",
gameOver: "SPILL SLUTT!",
playAgain: "Spill igjen",
pauseOverlay: "PAUSE",
noHighscores: "Ingen rekorder enn√•"
};
const gameCanvas = document.getElementById('gameCanvas');
const ctx = gameCanvas.getContext('2d');
const nextPieceCanvas = document.getElementById('nextPieceCanvas');
const nextPieceCtx = nextPieceCanvas.getContext('2d');
const scoreDisplay = document.getElementById('score');
const levelDisplay = document.getElementById('level');
const rewardEmojiDisplay = document.getElementById('rewardEmoji');
const gameStatusScreen = document.getElementById('gameStatusScreen');
const statusMessage = document.getElementById('statusMessage');
const statusButton = document.getElementById('statusButton');
const gameContainer = document.querySelector('.game-container');
const highscoreList = document.getElementById('highscore-list');
const resetHighscoreButton = document.getElementById('resetHighscoreButton');
const BOARD_WIDTH = 10;
const BOARD_HEIGHT = 20;
const HIGHSCORE_KEY = 'tetrisHighscores';
let blockSize;
let previewBlockSize;
let board = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0));
let currentPiece = null;
let nextPiece = null;
let score = 0;
let level = 1;
let fallInterval = 1000;
let gameLoop;
let isGameOver = false;
let isPaused = false;
const EMOJI_REWARDS = [
'üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üê®', 'üêØ', 'ü¶Å', 'üêÆ', 'üê∑', 'üê∏', 'üêµ', 'üêî', 'üêß', 'üê¶',
'ü¶â', 'üêò', 'üåù', 'üåπ', 'üçÑ', 'üçá', 'üçâ', 'üçå', 'üçí', 'üçì', 'üçî', 'üçï', 'üçú', 'üçü', 'üç¶', 'üç®', 'üç©', 'üç´',
'üç¨', 'üç≠', 'üç∞', 'üçπ', 'üçæ', 'üçø', 'üéÅ', 'üéà', 'üéâ', 'üé©', 'üé≠', 'üé∑', 'üé∏', 'üí£', 'üí•', 'üí∞', 'üï∫', 'üóø',
'üöÄ', 'üöÅ', 'üöÇ', 'üöî', 'üöñ', 'üöò', 'üöú', 'üö¢', 'üö≤', 'üöΩ', 'üõÄ', 'üõµ', 'üõ∂', 'üõ∑', 'üõ∏', 'üõπ',
'üõ∫', 'üõª', 'üõº', 'ü§ñ', 'ü§†', 'ü§π', 'ü•Å', 'ü•ù', 'ü•ï', 'ü•û', 'ü••', 'ü•¶', 'ü•®', 'ü¶Ä', 'ü¶É', 'ü¶Ñ', 'ü¶Ö',
'ü¶á', 'ü¶à', 'ü¶ã', 'ü¶å', 'ü¶ç', 'ü¶é', 'ü¶í', 'ü¶ú', 'ü•â', 'ü•à', 'ü•á',
];
const TETROMINOES = [
[[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],
[[1, 0, 0], [1, 1, 1], [0, 0, 0]],
[[0, 0, 1], [1, 1, 1], [0, 0, 0]],
[[1, 1], [1, 1]],
[[0, 1, 1], [1, 1, 0], [0, 0, 0]],
[[0, 1, 0], [1, 1, 1], [0, 0, 0]],
[[1, 1, 0], [0, 1, 1], [0, 0, 0]],
];
const COLORS = ['#00ffff', '#0000ff', '#ff8c00', '#ffff00', '#00ff00', '#ff00ff', '#ff0000'];
function updateStaticUIText() {
document.title = lang.title;
document.getElementById('score-label').textContent = lang.score;
document.getElementById('level-label').textContent = lang.level;
document.getElementById('next-label').textContent = lang.next;
document.querySelector('#controls-move .action-text').textContent = lang.controlsMove;
document.querySelector('#controls-rotate .action-text').textContent = lang.controlsRotate;
document.querySelector('#controls-speed .action-text').textContent = lang.controlsSpeed;
document.querySelector('#controls-drop .action-text').textContent = lang.controlsDrop;
document.querySelector('#controls-pause .action-text').textContent = lang.controlsPause;
document.getElementById('main-title').textContent = lang.title;
document.getElementById('highscore-title').textContent = lang.highscoreTitle;
document.getElementById('resetHighscoreButton').textContent = lang.resetScores;
gameContainer.dataset.pauseText = lang.pauseOverlay;
}
function initializeGame() {
board = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0));
score = 0;
level = 1;
fallInterval = 1000;
isGameOver = false;
scoreDisplay.textContent = score;
levelDisplay.textContent = level;
gameStatusScreen.style.display = 'none';
updateRewardEmoji();
}
function showStartScreen() {
statusMessage.textContent = lang.welcome;
statusButton.textContent = lang.startGame;
gameStatusScreen.style.display = 'flex';
}
function createPiece() {
const typeId = Math.floor(Math.random() * TETROMINOES.length);
const shape = TETROMINOES[typeId];
return {
shape: shape,
x: Math.floor(BOARD_WIDTH / 2) - Math.floor(shape[0].length / 2),
y: 0,
type: typeId,
};
}
function isValidMove(piece, offsetX, offsetY, shape) {
const shapeToCheck = shape || piece.shape;
for (let row = 0; row < shapeToCheck.length; row++) {
for (let col = 0; col < shapeToCheck[row].length; col++) {
if (shapeToCheck[row][col]) {
const newX = piece.x + col + offsetX;
const newY = piece.y + row + offsetY;
if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT) return false;
if (newY < 0) continue;
if (board[newY][newX] > 0) return false;
}
}
}
return true;
}
function rotate(piece) {
const originalShape = piece.shape;
const newShape = originalShape[0].map((_, colIndex) =>
originalShape.map((row) => row[colIndex]).reverse()
);
if (isValidMove(piece, 0, 0, newShape)) {
piece.shape = newShape;
} else {
const kicks = [[-1, 0], [1, 0], [0, -1], [-1, -1], [1, -1]];
for (const [kx, ky] of kicks) {
if (isValidMove(piece, kx, ky, newShape)) {
piece.shape = newShape;
piece.x += kx;
piece.y += ky;
return;
}
}
}
}
function freezePiece() {
for (let row = 0; row < currentPiece.shape.length; row++) {
for (let col = 0; col < currentPiece.shape[row].length; col++) {
if (currentPiece.shape[row][col]) {
if (currentPiece.y + row < 0) {
endGame();
return;
}
board[currentPiece.y + row][currentPiece.x + col] = currentPiece.type + 1;
}
}
}
}
function clearRows() {
let rowsCleared = 0;
for (let row = BOARD_HEIGHT - 1; row >= 0; row--) {
if (board[row].every((cell) => cell > 0)) {
rowsCleared++;
board.splice(row, 1);
board.unshift(Array(BOARD_WIDTH).fill(0));
row++;
}
}
if (rowsCleared > 0) {
updateScore(rowsCleared);
}
}
function dropPiece() {
if (isGameOver || isPaused) return;
if (isValidMove(currentPiece, 0, 1)) {
currentPiece.y++;
} else {
freezePiece();
clearRows();
if (!isGameOver) {
currentPiece = nextPiece;
nextPiece = createPiece();
drawNextPiece();
if (!isValidMove(currentPiece, 0, 0)) {
endGame();
}
}
}
drawGame();
}
function endGame() {
isGameOver = true;
clearInterval(gameLoop);
statusMessage.textContent = lang.gameOver;
statusButton.textContent = lang.playAgain;
gameStatusScreen.style.display = 'flex';
addHighscore(score);
displayHighscores();
}
function restartGame() {
initializeGame();
currentPiece = createPiece();
nextPiece = createPiece();
drawNextPiece();
drawGame();
if (gameLoop) clearInterval(gameLoop);
gameLoop = setInterval(dropPiece, fallInterval);
}
function updateScore(lines) {
const pointsPerLine = [0, 100, 300, 500, 800];
score += pointsPerLine[lines] * level;
scoreDisplay.textContent = score;
updateLevel();
updateRewardEmoji();
}
function updateLevel() {
const pointsForNextLevel = 3000;
const newLevel = Math.floor(score / pointsForNextLevel) + 1;
if (newLevel > level) {
level = newLevel;
levelDisplay.textContent = level;
const speedIncrease = 40;
const maxSpeed = 250;
fallInterval = Math.max(maxSpeed, fallInterval - speedIncrease);
clearInterval(gameLoop);
gameLoop = setInterval(dropPiece, fallInterval);
}
}
function updateRewardEmoji() {
const pointsPerEmoji = 3000;
const emojiIndex = Math.min(Math.floor(score / pointsPerEmoji), EMOJI_REWARDS.length - 1);
const newEmoji = EMOJI_REWARDS[emojiIndex];
if (rewardEmojiDisplay.textContent !== newEmoji) {
rewardEmojiDisplay.textContent = newEmoji;
rewardEmojiDisplay.classList.remove('pop-in-animation');
void rewardEmojiDisplay.offsetWidth;
rewardEmojiDisplay.classList.add('pop-in-animation');
}
}
function getHighscores() {
const scores = localStorage.getItem(HIGHSCORE_KEY);
return scores ? JSON.parse(scores) : [];
}
function saveHighscores(scores) {
localStorage.setItem(HIGHSCORE_KEY, JSON.stringify(scores));
}
function addHighscore(newScore) {
if (newScore === 0) return;
const scores = getHighscores();
scores.push(newScore);
scores.sort((a, b) => b - a);
const top10Scores = scores.slice(0, 10);
saveHighscores(top10Scores);
}
function displayHighscores() {
const scores = getHighscores();
highscoreList.innerHTML = '';
if (scores.length === 0) {
const li = document.createElement('li');
li.textContent = lang.noHighscores;
li.style.listStyleType = 'none';
li.style.textAlign = 'center';
highscoreList.appendChild(li);
} else {
scores.forEach((score, index) => {
const li = document.createElement('li');
li.textContent = score;
highscoreList.appendChild(li);
});
}
}
function resetHighscores() {
localStorage.removeItem(HIGHSCORE_KEY);
displayHighscores();
}
function drawBlock(x, y, typeId, context, currentBlockSize, isShadow = false) {
context.save();
const color = COLORS[typeId];
context.fillStyle = color;
if (isShadow) {
context.globalAlpha = 0.3;
context.strokeStyle = color;
context.lineWidth = 2;
context.strokeRect(x * currentBlockSize, y * currentBlockSize, currentBlockSize, currentBlockSize);
} else {
context.shadowColor = color;
context.shadowBlur = 8;
context.fillRect(x * currentBlockSize, y * currentBlockSize, currentBlockSize, currentBlockSize);
context.strokeStyle = 'rgba(255, 255, 255, 0.2)';
context.lineWidth = 1;
context.strokeRect(x * currentBlockSize, y * currentBlockSize, currentBlockSize, currentBlockSize);
}
context.restore();
}
function drawGame() {
ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
for (let row = 0; row < BOARD_HEIGHT; row++) {
for (let col = 0; col < BOARD_WIDTH; col++) {
if (board[row][col] > 0) {
const typeId = board[row][col] - 1;
drawBlock(col, row, typeId, ctx, blockSize);
}
}
}
if (currentPiece) {
const shadowY = findShadowPosition(currentPiece);
drawPiece({ ...currentPiece, y: shadowY }, ctx, blockSize, true);
drawPiece(currentPiece, ctx, blockSize, false);
}
}
function findShadowPosition(piece) {
let y = piece.y;
while (isValidMove(piece, 0, y - piece.y + 1)) {
y++;
}
return y;
}
function drawPiece(piece, context, currentBlockSize, isShadow = false) {
for (let row = 0; row < piece.shape.length; row++) {
if (piece.shape[row]) {
for (let col = 0; col < piece.shape[row].length; col++) {
if (piece.shape[row][col]) {
drawBlock(piece.x + col, piece.y + row, piece.type, context, currentBlockSize, isShadow);
}
}
}
}
}
function drawNextPiece() {
nextPieceCtx.clearRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
if (nextPiece) {
const shape = nextPiece.shape;
const pieceWidth = shape[0].length * previewBlockSize;
const pieceHeight = shape.length * previewBlockSize;
const startX = (nextPieceCanvas.width - pieceWidth) / 2;
const startY = (nextPieceCanvas.height - pieceHeight) / 2;
const clonedPiece = {
...nextPiece,
x: startX / previewBlockSize,
y: startY / previewBlockSize,
};
drawPiece(clonedPiece, nextPieceCtx, previewBlockSize);
}
}
function setGameScale() {
const heightScale = 0.9;
const totalHeight = window.innerHeight * heightScale;
blockSize = Math.floor(totalHeight / BOARD_HEIGHT);
gameCanvas.height = blockSize * BOARD_HEIGHT;
gameCanvas.width = blockSize * BOARD_WIDTH;
previewBlockSize = blockSize * 0.7;
nextPieceCanvas.width = nextPieceCanvas.clientWidth;
nextPieceCanvas.height = nextPieceCanvas.clientHeight;
}
function onWindowResize() {
setGameScale();
drawGame();
drawNextPiece();
}
function togglePause() {
if (isGameOver) return;
isPaused = !isPaused;
if (isPaused) {
clearInterval(gameLoop);
gameContainer.classList.add('paused');
} else {
gameLoop = setInterval(dropPiece, fallInterval);
gameContainer.classList.remove('paused');
}
}
document.addEventListener('keydown', (e) => {
if (e.key.toLowerCase() === 'p') {
togglePause();
return;
}
if (isGameOver || !currentPiece || isPaused) return;
let handled = true;
switch (e.key) {
case 'ArrowLeft':
if (isValidMove(currentPiece, -1, 0)) currentPiece.x--;
break;
case 'ArrowRight':
if (isValidMove(currentPiece, 1, 0)) currentPiece.x++;
break;
case 'ArrowDown':
if (isValidMove(currentPiece, 0, 1)) {
currentPiece.y++;
score += 1;
scoreDisplay.textContent = score;
}
break;
case 'ArrowUp':
rotate(currentPiece);
break;
case ' ':
e.preventDefault();
let rowsDropped = 0;
while (isValidMove(currentPiece, 0, 1)) {
currentPiece.y++;
rowsDropped++;
}
score += rowsDropped * 2; // Gir ekstra poeng for "hard drop"
scoreDisplay.textContent = score;
dropPiece();
break;
default:
handled = false;
break;
}
if (handled) drawGame();
});
statusButton.addEventListener('click', restartGame);
resetHighscoreButton.addEventListener('click', resetHighscores);
let resizeTimer;
window.addEventListener('resize', () => {
clearTimeout(resizeTimer);
resizeTimer = setTimeout(onWindowResize, 150);
});
// Initialiser spillet ved lasting
updateStaticUIText();
setGameScale();
displayHighscores();
showStartScreen();
</script>
</body>
</html>
