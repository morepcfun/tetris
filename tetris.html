<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris</title>
    <style>
        :root {
            --primary-color: #00ffff;
            --secondary-color: #ff00ff;
            --score-color: #00ff00;
            --reward-color: #ffff00;
            --dark-bg: #000000;
            --black-bg: #000000;
            --text-color: #e0e0e0;
            --game-over-color: #ff0000;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: -1;
            background-image: url("data:image/svg+xml,<svg width='40' height='40' xmlns='http://www.w3.org/2000/svg'><rect width='40' height='40' fill='%23030328'/><path d='M40 0v40H0' fill='none' stroke='%2300d1ff' stroke-width='0.5'/></svg>");
            background-size: 40px;
            background-repeat: repeat;
            background-position: top;
            opacity: 0.90;
            filter: blur(0px);
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #121212;
            color: var(--text-color);
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .game-container {
            display: flex;
            gap: 3vh;
            background-color: var(--dark-bg);
            padding: 2vh;
            border-radius: 2vh;
            box-shadow: 0 0 5vh rgba(0, 255, 255, 0.6),
                        0 0 2.5vh rgba(0, 255, 255, 0.4) inset;
            border: 0.4vh solid var(--primary-color);
            position: relative;
        }

        .game-container.paused::before {
            content: attr(data-pause-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10vh;
            color: var(--reward-color);
            background-color: rgba(15, 15, 28, 0.85);
            text-shadow: 0 0 2vh var(--reward-color);
            z-index: 200;
            border-radius: 2vh;
            pointer-events: none;
        }

        canvas#gameCanvas {
            background-color: var(--black-bg);
            border: 0.3vh solid var(--primary-color);
            box-shadow: 0 0 2.5vh rgba(0, 255, 255, 0.5);
            display: block;
        }

        .info-panel,
        .highscore-panel {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            width: 30vh;
            padding: 2vh;
            background-color: var(--dark-bg);
            border-radius: 1.5vh;
        }

        .info-panel {
            border: 0.3vh solid var(--secondary-color);
            box-shadow: 0 0 3vh rgba(255, 0, 255, 0.6),
                        0 0 1.5vh rgba(255, 0, 255, 0.4) inset;
        }

        .highscore-panel {
            border: 0.3vh solid var(--score-color);
            box-shadow: 0 0 3vh rgba(0, 255, 0, 0.6),
                        0 0 1.5vh rgba(0, 255, 0, 0.4) inset;
        }

        .highscore-panel h1 {
            text-align: center;
            font-size: 4vh;
            color: var(--primary-color);
            text-shadow: 0 0 1vh var(--primary-color);
            margin: 0 0 1.5vh 0;
        }
        
        .highscore-panel h2 {
            font-size: 3.6vh;
            color: var(--score-color);
            text-shadow: 0 0 1vh var(--score-color);
            margin: 0 0 1.5vh 0;
        }

        .highscore-panel ol {
            text-align: left;
            width: 100%;
            padding-left: 3vh;
            margin: 0;
            font-size: 3.1vh;
            color: var(--text-color);
            list-style-type: decimal;
        }

        .highscore-panel li {
            margin-bottom: 0.8vh;
            text-shadow: 0 0 0.5vh var(--primary-color);
        }

        .info-section {
            width: 100%;
            text-align: center;
            margin-bottom: 1.5vh;
        }

        .info-section h2 {
            font-size: 3.4vh;
            color: var(--score-color);
            text-shadow: 0 0 1vh var(--score-color);
            margin: 0 0 0.5vh 0;
        }

        .info-section p {
            font-size: 4.5vh;
            color: var(--primary-color);
            text-shadow: 0 0 0.8vh var(--primary-color);
            margin: 0;
        }

        #nextPieceCanvas {
            background-color: #050505;
            border: 0.2vh solid var(--score-color);
            box-shadow: 0 0 1.5vh rgba(0, 255, 0, 0.5);
            margin-top: 1vh;
            margin-bottom: 2vh;
            width: 100%;
            height: 12vh;
        }

        .reward-window {
            width: 100%;
            height: 25vh;
            background-color: var(--black-bg);
            border: 0.4vh solid var(--reward-color);
            box-shadow: 0 0 3vh rgba(255, 255, 0, 0.6),
                        0 0 1.5vh rgba(255, 255, 0, 0.4) inset;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            border-radius: 1vh;
            margin-top: auto;
        }

        #rewardEmoji {
            font-size: 16vh;
            line-height: 1;
        }

        @keyframes pop-in {
            from {
                transform: scale(0.1) rotate(-45deg);
                opacity: 0;
            }
            to {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        .pop-in-animation {
            animation: pop-in 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 7vh;
            color: var(--game-over-color);
            text-shadow: 0 0 2vh var(--game-over-color);
            z-index: 100;
            border-radius: 1.8vh;
            text-align: center;
        }

        .game-over-screen button {
            background-color: var(--score-color);
            color: var(--dark-bg);
            border: 0.3vh solid #00cc00;
            padding: 2vh 4vh;
            font-family: 'Courier New', Courier, monospace;
            font-size: 2.5vh;
            cursor: pointer;
            border-radius: 1vh;
            box-shadow: 0 0 1.5vh rgba(0, 255, 0, 0.7);
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: 3vh;
        }

        .game-over-screen button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 2.5vh rgba(0, 255, 0, 1);
        }

        #resetHighscoreButton {
            background-color: var(--game-over-color);
            color: var(--text-color);
            border: 0.3vh solid #cc0000;
            padding: 1.5vh 3vh;
            font-family: 'Courier New', Courier, monospace;
            font-size: 2.2vh;
            cursor: pointer;
            border-radius: 1vh;
            box-shadow: 0 0 1.5vh rgba(255, 0, 0, 0.7);
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: auto;
        }

        #resetHighscoreButton:hover {
            transform: scale(1.05);
            box-shadow: 0 0 2.5vh rgba(255, 0, 0, 1);
        }

        #controls {
            width: 100%;
            margin-top: 2vh;
            font-size: 2vh;
            color: var(--secondary-color);
            opacity: 0.8;
        }

        #controls div {
            display: flex;
            align-items: center;
            margin-bottom: 0.8vh;
        }

        #controls span.key {
            display: inline-block;
            background-color: #222;
            border: 1px solid var(--secondary-color);
            border-radius: 0.5vh;
            padding: 0.3vh 1vh;
            margin-right: 1.5vh;
            font-weight: bold;
            color: var(--text-color);
            min-width: 4vh;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="info-panel">
            <div class="info-section">
                <h2 id="score-label"></h2>
                <p id="score">0</p>
            </div>
            <div class="info-section">
                <h2 id="level-label"></h2>
                <p id="level">1</p>
            </div>
            <div class="info-section">
                <h2 id="next-label"></h2>
                <canvas id="nextPieceCanvas"></canvas>
                <div id="controls">
                    <div id="controls-move"><span class="key">← →</span><span class="action-text"></span></div>
                    <div id="controls-rotate"><span class="key">↑</span><span class="action-text"></span></div>
                    <div id="controls-speed"><span class="key">↓</span><span class="action-text"></span></div>
                    <div id="controls-drop"><span class="key">Space</span><span class="action-text"></span></div>
                    <div id="controls-pause"><span class="key">P</span><span class="action-text"></span></div>
                </div>
            </div>
            <div class="reward-window">
                <div id="rewardEmoji" aria-label="Reward Emoji"></div>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div class="highscore-panel">
            <h1 id="main-title"></h1>
            <h2 id="highscore-title"></h2>
            <ol id="highscore-list"></ol>
            <button id="resetHighscoreButton"></button>
        </div>

        <div class="game-over-screen" id="gameStatusScreen">
            <div id="statusMessage"></div>
            <button id="statusButton"></button>
        </div>
    </div>

    <script>
        // --- LANGUAGE & TEXT CONFIGURATION ---
        const lang = {
            title: "Tetris",
            score: "Score",
            level: "Level",
            next: "Next",
            controlsMove: "Move",
            controlsRotate: "Rotate",
            controlsSpeed: "Speed Up",
            controlsDrop: "Drop",
            controlsPause: "Pause",
            highscoreTitle: "High Scores",
            resetScores: "Reset Scores",
            welcome: "Welcome to Tetris",
            startGame: "Start Game",
            gameOver: "GAME OVER!",
            playAgain: "Play Again",
            pauseOverlay: "PAUSED",
            noHighscores: "No high scores yet"
        };

        // --- DOM ELEMENT REFERENCES ---
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d');
        const nextPieceCanvas = document.getElementById('nextPieceCanvas');
        const nextPieceCtx = nextPieceCanvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const levelDisplay = document.getElementById('level');
        const rewardEmojiDisplay = document.getElementById('rewardEmoji');
        const gameStatusScreen = document.getElementById('gameStatusScreen');
        const statusMessage = document.getElementById('statusMessage');
        const statusButton = document.getElementById('statusButton');
        const gameContainer = document.querySelector('.game-container');
        const highscoreList = document.getElementById('highscore-list');
        const resetHighscoreButton = document.getElementById('resetHighscoreButton');

        // --- GAME CONSTANTS ---
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const HIGHSCORE_KEY = 'tetrisHighscores';
        const TETROMINOES = [
            [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], // I
            [[1, 0, 0], [1, 1, 1], [0, 0, 0]],                     // J
            [[0, 0, 1], [1, 1, 1], [0, 0, 0]],                     // L
            [[1, 1], [1, 1]],                                     // O
            [[0, 1, 1], [1, 1, 0], [0, 0, 0]],                     // S
            [[0, 1, 0], [1, 1, 1], [0, 0, 0]],                     // T
            [[1, 1, 0], [0, 1, 1], [0, 0, 0]],                     // Z
        ];
        const COLORS = ['#00ffff', '#0000ff', '#ff8c00', '#ffff00', '#00ff00', '#ff00ff', '#ff0000'];
        const EMOJI_REWARDS = [
            '🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼', '🐨', '🐯', '🦁', '🐮', '🐷', '🐸', '🐵', '🐔', '🐧', '🐦',
            '🦉', '🐘', '🌝', '🌹', '🍄', '🍇', '🍉', '🍌', '🍒', '🍓', '🍔', '🍕', '🍜', '🍟', '🍦', '🍨', '🍩', '🍫',
            '🍬', '🍭', '🍰', '🍹', '🍾', '🍿', '🎁', '🎈', '🎉', '🎩', '🎭', '🎷', '🎸', '💣', '💥', '💰', '🕺', '🗿',
            '🚀', '🚁', '🚂', '🚔', '🚖', '🚘', '🚜', '🚢', '🚲', '🚽', '🛀', '🛵', '🛶', '🛷', '🛸', '🛹',
            '🛺', '🛻', '🛼', '🤖', '🤠', '🤹', '🥁', '🥝', '🥕', '🥞', '🥥', '🥦', '🥨', '🦀', '🦃', '🦄', '🦅',
            '🦇', '🦈', '🦋', '🦌', '🦍', '🦎', '🦒', '🦜', '🥉', '🥈', '🥇',
        ];

        // --- GAME STATE VARIABLES ---
        let blockSize;
        let previewBlockSize;
        let board = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0));
        let currentPiece = null;
        let nextPiece = null;
        let score = 0;
        let level = 1;
        let fallInterval = 1000;
        let gameLoop;
        let isGameOver = false;
        let isPaused = false;
        let resizeTimer;

        // --- UI & INITIALIZATION ---
        function updateStaticUIText() {
            document.title = lang.title;
            document.getElementById('score-label').textContent = lang.score;
            document.getElementById('level-label').textContent = lang.level;
            document.getElementById('next-label').textContent = lang.next;
            document.querySelector('#controls-move .action-text').textContent = lang.controlsMove;
            document.querySelector('#controls-rotate .action-text').textContent = lang.controlsRotate;
            document.querySelector('#controls-speed .action-text').textContent = lang.controlsSpeed;
            document.querySelector('#controls-drop .action-text').textContent = lang.controlsDrop;
            document.querySelector('#controls-pause .action-text').textContent = lang.controlsPause;
            document.getElementById('main-title').textContent = lang.title;
            document.getElementById('highscore-title').textContent = lang.highscoreTitle;
            document.getElementById('resetHighscoreButton').textContent = lang.resetScores;
            gameContainer.dataset.pauseText = lang.pauseOverlay;
        }

        function setGameScale() {
            const heightScale = 0.9;
            const totalHeight = window.innerHeight * heightScale;
            blockSize = Math.floor(totalHeight / BOARD_HEIGHT);
            gameCanvas.height = blockSize * BOARD_HEIGHT;
            gameCanvas.width = blockSize * BOARD_WIDTH;
            previewBlockSize = blockSize * 0.7;
            nextPieceCanvas.width = nextPieceCanvas.clientWidth;
            nextPieceCanvas.height = nextPieceCanvas.clientHeight;
        }

        function initializeGame() {
            board = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0));
            score = 0;
            level = 1;
            fallInterval = 1000;
            isGameOver = false;
            scoreDisplay.textContent = score;
            levelDisplay.textContent = level;
            gameStatusScreen.style.display = 'none';
            updateRewardEmoji();
        }

        function showStartScreen() {
            statusMessage.textContent = lang.welcome;
            statusButton.textContent = lang.startGame;
            gameStatusScreen.style.display = 'flex';
        }

        // --- CORE GAME LOGIC ---
        function createPiece() {
            const typeId = Math.floor(Math.random() * TETROMINOES.length);
            const shape = TETROMINOES[typeId];
            return {
                shape: shape,
                x: Math.floor(BOARD_WIDTH / 2) - Math.floor(shape[0].length / 2),
                y: 0,
                type: typeId,
            };
        }

        function isValidMove(piece, offsetX, offsetY, shape) {
            const shapeToCheck = shape || piece.shape;
            for (let row = 0; row < shapeToCheck.length; row++) {
                for (let col = 0; col < shapeToCheck[row].length; col++) {
                    if (shapeToCheck[row][col]) {
                        const newX = piece.x + col + offsetX;
                        const newY = piece.y + row + offsetY;
                        if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT) return false;
                        if (newY < 0) continue;
                        if (board[newY][newX] > 0) return false;
                    }
                }
            }
            return true;
        }

        function rotate(piece) {
            const originalShape = piece.shape;
            const newShape = originalShape[0].map((_, colIndex) =>
                originalShape.map((row) => row[colIndex]).reverse()
            );

            if (isValidMove(piece, 0, 0, newShape)) {
                piece.shape = newShape;
                return;
            }

            // Simple wall-kick attempts
            const kicks = [[-1, 0], [1, 0], [0, -1], [-1, -1], [1, -1]];
            for (const [kx, ky] of kicks) {
                if (isValidMove(piece, kx, ky, newShape)) {
                    piece.shape = newShape;
                    piece.x += kx;
                    piece.y += ky;
                    return;
                }
            }
        }

        function freezePiece() {
            for (let row = 0; row < currentPiece.shape.length; row++) {
                for (let col = 0; col < currentPiece.shape[row].length; col++) {
                    if (currentPiece.shape[row][col]) {
                        if (currentPiece.y + row < 0) {
                            endGame();
                            return;
                        }
                        board[currentPiece.y + row][currentPiece.x + col] = currentPiece.type + 1;
                    }
                }
            }
        }

        function clearRows() {
            let rowsCleared = 0;
            for (let row = BOARD_HEIGHT - 1; row >= 0; row--) {
                if (board[row].every((cell) => cell > 0)) {
                    rowsCleared++;
                    board.splice(row, 1);
                    board.unshift(Array(BOARD_WIDTH).fill(0));
                    row++; // Re-check the same row index as it's now a new row
                }
            }
            if (rowsCleared > 0) {
                updateScore(rowsCleared);
            }
        }

        function dropPiece() {
            if (isGameOver || isPaused) return;

            if (isValidMove(currentPiece, 0, 1)) {
                currentPiece.y++;
            } else {
                freezePiece();
                clearRows();
                if (!isGameOver) {
                    currentPiece = nextPiece;
                    nextPiece = createPiece();
                    drawNextPiece();
                    if (!isValidMove(currentPiece, 0, 0)) {
                        endGame();
                    }
                }
            }
            drawGame();
        }

        function hardDrop() {
            if (isGameOver || isPaused || !currentPiece) return;
            let rowsDropped = 0;
            while (isValidMove(currentPiece, 0, 1)) {
                currentPiece.y++;
                rowsDropped++;
            }
            score += rowsDropped * 2; // Extra points for hard drop
            scoreDisplay.textContent = score;
            dropPiece(); // This will immediately freeze and spawn the next piece
        }

        function gameLoopTick() {
            dropPiece();
        }

        // --- SCORING & LEVELING ---
        function updateScore(lines) {
            const pointsPerLine = [0, 100, 300, 500, 800]; // 0, 1, 2, 3, 4 lines
            score += pointsPerLine[lines] * level;
            scoreDisplay.textContent = score;
            updateLevel();
            updateRewardEmoji();
        }

        function updateLevel() {
            const pointsForNextLevel = 3000;
            const newLevel = Math.floor(score / pointsForNextLevel) + 1;
            if (newLevel > level) {
                level = newLevel;
                levelDisplay.textContent = level;
                const speedIncrease = 40; // ms
                const maxSpeed = 250; // ms
                fallInterval = Math.max(maxSpeed, fallInterval - speedIncrease);
                clearInterval(gameLoop);
                gameLoop = setInterval(gameLoopTick, fallInterval);
            }
        }

        function updateRewardEmoji() {
            const pointsPerEmoji = 3000;
            const emojiIndex = Math.min(Math.floor(score / pointsPerEmoji), EMOJI_REWARDS.length - 1);
            const newEmoji = EMOJI_REWARDS[emojiIndex];
            if (rewardEmojiDisplay.textContent !== newEmoji) {
                rewardEmojiDisplay.textContent = newEmoji;
                rewardEmojiDisplay.classList.remove('pop-in-animation');
                void rewardEmojiDisplay.offsetWidth; // Trigger reflow to restart animation
                rewardEmojiDisplay.classList.add('pop-in-animation');
            }
        }

        // --- HIGH SCORE MANAGEMENT ---
        function getHighscores() {
            const scores = localStorage.getItem(HIGHSCORE_KEY);
            return scores ? JSON.parse(scores) : [];
        }

        function saveHighscores(scores) {
            localStorage.setItem(HIGHSCORE_KEY, JSON.stringify(scores));
        }

        function addHighscore(newScore) {
            if (newScore === 0) return;
            const scores = getHighscores();
            scores.push(newScore);
            scores.sort((a, b) => b - a);
            const top10Scores = scores.slice(0, 10);
            saveHighscores(top10Scores);
        }

        function displayHighscores() {
            const scores = getHighscores();
            highscoreList.innerHTML = '';
            if (scores.length === 0) {
                const li = document.createElement('li');
                li.textContent = lang.noHighscores;
                li.style.listStyleType = 'none';
                li.style.textAlign = 'center';
                highscoreList.appendChild(li);
            } else {
                scores.forEach((score) => {
                    const li = document.createElement('li');
                    li.textContent = score;
                    highscoreList.appendChild(li);
                });
            }
        }

        function resetHighscores() {
            localStorage.removeItem(HIGHSCORE_KEY);
            displayHighscores();
        }

        // --- DRAWING FUNCTIONS ---
        function drawBlock(x, y, typeId, context, currentBlockSize, isShadow = false) {
            context.save();
            const color = COLORS[typeId];
            const px = x * currentBlockSize;
            const py = y * currentBlockSize;

            if (isShadow) {
                context.globalAlpha = 0.3;
                context.strokeStyle = color;
                context.lineWidth = 2;
                context.strokeRect(px, py, currentBlockSize, currentBlockSize);
            } else {
                context.fillStyle = color;
                context.shadowColor = color;
                context.shadowBlur = 8;
                context.fillRect(px, py, currentBlockSize, currentBlockSize);
                context.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                context.lineWidth = 1;
                context.strokeRect(px, py, currentBlockSize, currentBlockSize);
            }
            context.restore();
        }
        
        function findShadowPosition(piece) {
            let y = piece.y;
            while (isValidMove(piece, 0, y - piece.y + 1)) {
                y++;
            }
            return y;
        }

        function drawPiece(piece, context, currentBlockSize, isShadow = false) {
            const shape = piece.shape;
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        drawBlock(piece.x + col, piece.y + row, piece.type, context, currentBlockSize, isShadow);
                    }
                }
            }
        }
        
        function drawBoard() {
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                for (let col = 0; col < BOARD_WIDTH; col++) {
                    if (board[row][col] > 0) {
                        const typeId = board[row][col] - 1;
                        drawBlock(col, row, typeId, ctx, blockSize);
                    }
                }
            }
        }

        function drawGame() {
            ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            drawBoard();
            if (currentPiece) {
                const shadowY = findShadowPosition(currentPiece);
                drawPiece({ ...currentPiece, y: shadowY }, ctx, blockSize, true);
                drawPiece(currentPiece, ctx, blockSize, false);
            }
        }

        function drawNextPiece() {
            nextPieceCtx.clearRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
            if (nextPiece) {
                const shape = nextPiece.shape;
                const pieceWidth = shape[0].length * previewBlockSize;
                const pieceHeight = shape.length * previewBlockSize;
                const startX = (nextPieceCanvas.width - pieceWidth) / 2;
                const startY = (nextPieceCanvas.height - pieceHeight) / 2;

                // Create a temporary piece for drawing, positioned correctly in the preview
                const previewPiece = {
                    ...nextPiece,
                    x: startX / previewBlockSize,
                    y: startY / previewBlockSize,
                };
                drawPiece(previewPiece, nextPieceCtx, previewBlockSize);
            }
        }

        // --- GAME FLOW & CONTROL ---
        function restartGame() {
            initializeGame();
            currentPiece = createPiece();
            nextPiece = createPiece();
            drawNextPiece();
            drawGame();
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(gameLoopTick, fallInterval);
        }

        function endGame() {
            isGameOver = true;
            clearInterval(gameLoop);
            statusMessage.textContent = lang.gameOver;
            statusButton.textContent = lang.playAgain;
            gameStatusScreen.style.display = 'flex';
            addHighscore(score);
            displayHighscores();
        }

        function togglePause() {
            if (isGameOver) return;
            isPaused = !isPaused;
            if (isPaused) {
                clearInterval(gameLoop);
                gameContainer.classList.add('paused');
            } else {
                gameLoop = setInterval(gameLoopTick, fallInterval);
                gameContainer.classList.remove('paused');
            }
        }

        function handleKeyDown(e) {
            if (e.key.toLowerCase() === 'p') {
                togglePause();
                return;
            }

            if (isGameOver || !currentPiece || isPaused) return;

            let handled = true;
            switch (e.key) {
                case 'ArrowLeft':
                    if (isValidMove(currentPiece, -1, 0)) currentPiece.x--;
                    break;
                case 'ArrowRight':
                    if (isValidMove(currentPiece, 1, 0)) currentPiece.x++;
                    break;
                case 'ArrowDown':
                    if (isValidMove(currentPiece, 0, 1)) {
                        currentPiece.y++;
                        score += 1; // Bonus point for soft drop
                        scoreDisplay.textContent = score;
                    }
                    break;
                case 'ArrowUp':
                    rotate(currentPiece);
                    break;
                case ' ':
                    e.preventDefault();
                    hardDrop();
                    break;
                default:
                    handled = false;
                    break;
            }
            if (handled) drawGame();
        }
        
        function onWindowResize() {
            setGameScale();
            drawGame();
            drawNextPiece();
        }
        
        // --- EVENT LISTENERS ---
        document.addEventListener('keydown', handleKeyDown);
        statusButton.addEventListener('click', restartGame);
        resetHighscoreButton.addEventListener('click', resetHighscores);
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(onWindowResize, 150);
        });

        // --- INITIALIZE ON LOAD ---
        function init() {
            updateStaticUIText();
            setGameScale();
            displayHighscores();
            showStartScreen();
        }

        init();
    </script>
</body>
</html>